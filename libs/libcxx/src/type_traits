#ifndef _STD_TYPE_TRAITS_HPP
#define _STD_TYPE_TRAITS_HPP

#include <cstddef>

namespace std {

template <typename T, T v>
struct integral_constant {
    constexpr static T value = v;
    using value_type = T;
    using type = integral_constant;

    constexpr operator value_type() const noexcept { return value; }
    constexpr value_type operator ()() const noexcept { return value; }
};

template <bool v>
using bool_constant = integral_constant<bool, v>;

using true_type  = bool_constant<true>;
using false_type = bool_constant<false>;

/**
 * @brief If `B` is `true` at compile-time, then member `type` is `T`.
 * Otherwise, `type` is `F`.
 *
 * @tparam B compile-time boolean value which is `true` or `false`
 * @tparam T type to set member `type` to if `B` is `true`
 * @tparam F type to set member `type` to if `B` is `false`
 * @param type `T` if `B` is `true`; otherwise, `F`
 */
template <bool B, typename T, typename F>
struct conditional { using type = T; };

/**
 * @brief If `B` is `true` at compile-time, then member `type` is `T`.
 * Otherwise, `type` is `F`.
 *
 * @tparam B compile-time boolean value which is `true` or `false`
 * @tparam T type to set member `type` to if `B` is `true`
 * @tparam F type to set member `type` to if `B` is `false`
 * @param type `T` if `B` is `true`; otherwise, `F`
 */
template <typename T, typename F>
struct conditional<false, T, F> { using type = F; };

/**
 * @brief `T` if `B` is `true` at compile-time; otherwise, `F`.
 * 
 * @tparam B compile-time boolean value which is `true` or `false`
 * @tparam T type if `B` is `true`
 * @tparam F type if `B` is `false`
 */
template <bool B, typename T, typename F>
using conditional_t = typename conditional<B,T,F>::type;

/**
 * @brief If `B` is `true` at compile-time, then member `type` is `T`.
 * Otherwise, `type` is not defined.
 *
 * @tparam B compile-time boolean value which is `true` or `false`
 * @tparam T type to set member `type` to if `B` is `true`
 * @param type `T` if `B` is `true`; otherwise, not defined
 */
template <bool B, typename T = void>
struct enable_if {};

/**
 * @brief If `B` is `true` at compile-time, then member `type` is `T`.
 * Otherwise, `type` is not defined.
 *
 * @tparam B compile-time boolean value which is `true` or `false`
 * @tparam T type to set member `type` to if `B` is `true`
 * @param type `T` if `B` is `true`; otherwise, not defined
 */
template <typename T>
struct enable_if<true, T> { using type = T; };

/**
 * @brief `T` if `B` is `true` at compile-time; otherwise, not defined.
 * 
 * @tparam B compile-time boolean value which is `true` or `false`
 * @tparam T type if `B` is `true`
 */
template <bool B, typename T = void>
using enable_if_t = typename enable_if<B,T>::type;

/**
 * Removes the topmost const qualifier and/or the topmost volatile qualifier
 * (if any) from the given type.
 * 
 * @tparam T type with possible const/volatile qualifiers
 * @param type type with topmost const/volatile qualifiers removed (if any) 
 */
template <typename T>
struct remove_cv { typedef T type; };

/**
 * Removes the topmost const qualifier and/or the topmost volatile qualifier
 * (if any) from the given type.
 * 
 * @tparam T type with possible const/volatile qualifiers
 * @param type type with topmost const/volatile qualifiers removed (if any) 
 */
template <typename T>
struct remove_cv<const T> { typedef T type; };

/**
 * Removes the topmost const qualifier and/or the topmost volatile qualifier
 * (if any) from the given type.
 * 
 * @tparam T type with possible const/volatile qualifiers
 * @param type type with topmost const/volatile qualifiers removed (if any) 
 */
template <typename T>
struct remove_cv<volatile T> { typedef T type; };

/**
 * Removes the topmost const qualifier and/or the topmost volatile qualifier
 * (if any) from the given type.
 * 
 * @tparam T type with possible const/volatile qualifiers
 * @param type type with topmost const/volatile qualifiers removed (if any) 
 */
template <typename T>
struct remove_cv<const volatile T> { typedef T type; };

/**
 * Type with the topmost const qualifier and/or the topmost volatile
 * qualifier removed (if any).
 * 
 * @tparam T type with possible const/volatile qualifiers
 */
template <typename T>
using remove_cv_t = typename remove_cv<T>::type;
 
 /**
 * Removes the topmost const qualifier (if any) from the given type.
 * 
 * @tparam T type with possible const qualifier
 * @param type type with topmost const qualifier removed (if any)
 */
template <typename T>
struct remove_const { typedef T type; };

 /**
 * Removes the topmost const qualifier (if any) from the given type.
 * 
 * @tparam T type with possible const qualifier
 * @param type type with topmost const qualifier removed (if any)
 */
template <typename T>
struct remove_const<const T> { typedef T type; };

/**
 * Type with the topmost const qualifier removed (if any).
 * 
 * @tparam T type with possible const qualifier
 */
template <typename T>
using remove_const_t = typename remove_const<T>::type;
 
/**
 * Removes the topmost volatile qualifier (if any) from the given type.
 * 
 * @tparam T type with possible volatile qualifier
 * @param type type with topmost volatile qualifier removed (if any)
 */
template <typename T>
struct remove_volatile { typedef T type; };

/**
 * Removes the topmost volatile qualifier (if any) from the given type.
 * 
 * @tparam T type with possible volatile qualifier
 * @param type type with topmost volatile qualifier removed (if any)
 */
template <typename T>
struct remove_volatile<volatile T> { typedef T type; };

/**
 * Type `T` with the topmost volatile qualifier removed (if any).
 * 
 * @tparam T type with possible volatile qualifier
 */
template <typename T>
using remove_volatile_t = typename remove_volatile<T>::type;

/**
 * If the type `T` is a reference type, member `type` is equal to the type
 * referred to by T. If the type T is not a reference type, member `type` is
 * equal to `T`.
 *
 * @tparam T possible reference type
 * @param type the type referred to by `T`, or `T`
 */
template <typename T>
struct remove_reference { typedef T type; };

/**
 * If the type `T` is a reference type, member `type` is equal to the type
 * referred to by T. If the type T is not a reference type, member `type` is
 * equal to `T`.
 *
 * @tparam T possible reference type
 * @param type the type referred to by `T`, or `T`
 */
template <typename T>
struct remove_reference<T&> { typedef T type; };

/**
 * If the type `T` is a reference type, member `type` is equal to the type
 * referred to by T. If the type T is not a reference type, member `type` is
 * equal to `T`.
 *
 * @tparam T possible reference type
 * @param type the type referred to by `T`, or `T`
 */
template <typename T>
struct remove_reference<T&&> { typedef T type; };

/**
 * Underlying type that `T` is referring to, or `T` if `T` is not a reference
 * type.
 * 
 * @tparam T possible reference type
 */
template <typename T>
using remove_reference_t = typename remove_reference<T>::type;

template <typename T>
struct is_reference : false_type {};

template <typename T>
struct is_reference<T&> : true_type {};

template <typename T>
struct is_reference<T&&> : true_type {};

template <typename T>
struct is_lvalue_reference : false_type {};

template <typename T>
struct is_lvalue_reference<T&> : true_type {};

template <typename T>
struct is_rvalue_reference : false_type {};

template <typename T>
struct is_rvalue_reference<T&&> : true_type {};

template <typename T>
struct __is_void : public false_type {};

template <>
struct __is_void<void> : public true_type {};

/**
 * @brief If `T` is a `void` type with optional const/volatile qualifiers, then
 * `value` is `true`. Otherwise, `value` is `false`.
 *
 * @details
 * The types considered void that result in `value` being `true` are:
 *
 * - `void`
 * - `const void`
 * - `volatile void`
 * - `const volatile void`
 *
 * All other types result in `value` being `false`.
 * 
 * @tparam T possible void type with optional const/volatile qualifiers
 * @param value `true` if `T` is a void type with optional const/volatile
 * qualifiers; `false` otherwise
 */
template <typename T>
struct is_void : public __is_void<remove_cv_t<T>>::type {};

/**
 * @brief `True` if `T` is a void type with optional const/volatile qualifiers;
 * otherwise, `false`.
 * 
 * @tparam T possible void type with optional const/volatile qualifiers
 */
template <typename T>
inline constexpr bool is_void_v = is_void<T>::value;

template <typename T>
struct __is_null_pointer : public false_type {};

template <>
struct __is_null_pointer<nullptr_t> : public true_type {};

/**
 * @brief If `T` is the `std::nullptr_t` type with optional const/volatile
 * qualifiers, then `value` is `true`. Otherwise, `value` is `false`.
 *
 * @details
 * The types considered `std::nullptr_t` that result in `value` being `true`
 * are:
 *
 * - `std::nullptr_t`
 * - `const std::nullptr_t`
 * - `volatile std::nullptr_t`
 * - `const volatile std::nullptr_t`
 *
 * All other types result in `value` being `false`.
 * 
 * @tparam T possible `std::nullptr_t` type with optional const/volatile
 * qualifiers
 * @param value `true` if `T` is the `std::nullptr_t` type with optional const/
 * volatile qualifiers; `false` otherwise
 */
template <typename T>
struct is_null_pointer : public __is_null_pointer<remove_cv_t<T>>::type {};

/**
 * @brief `True` if `T` is the `std::nullptr_t` type with optional const/
 * volatile qualifiers; otherwise, `false`.
 * 
 * @tparam T possible `std::nullptr_t` type with optional const/volatile
 * qualifiers
 */
template <typename T>
inline constexpr bool is_null_pointer_v = is_null_pointer<T>::value;

template <typename T>
struct __is_integral : public false_type {};

template <>
struct __is_integral<bool> : public true_type {};

template <>
struct __is_integral<char> : public true_type {};

template <>
struct __is_integral<signed char> : public true_type {};

template <>
struct __is_integral<unsigned char> : public true_type {};

template <>
struct __is_integral<char8_t> : public true_type {};

template <>
struct __is_integral<char16_t> : public true_type {};

template <>
struct __is_integral<char32_t> : public true_type {};

template <>
struct __is_integral<wchar_t> : public true_type {};

template <>
struct __is_integral<short> : public true_type {};

template <>
struct __is_integral<unsigned short> : public true_type {};

template <>
struct __is_integral<int> : public true_type {};

template <>
struct __is_integral<unsigned int> : public true_type {};

template <>
struct __is_integral<long> : public true_type {};

template <>
struct __is_integral<unsigned long> : public true_type {};

template <>
struct __is_integral<long long> : public true_type {};

template <>
struct __is_integral<unsigned long long> : public true_type {};

/**
 * @brief If `T` is an integral type with optional const/volatile qualifiers,
 * then `value` is `true`. Otherwise, `value` is `false`.
 *
 * @details
 * The types considered integral that result in `value` being `true` are:
 *
 * - `bool`
 * - `char` (signed, unsigned, or unspecified)
 * - `char8_t`
 * - `char16_t`
 * - `char32_t`
 * - `wchar_t`
 * - `short` (signed, unsigned, or unspecified)
 * - `int` (signed, unsigned, or unspecified)
 * - `long` (signed, unsigned, or unspecified)
 * - `long long` (signed, unsigned, or unspecified)
 *
 * Any of these types may also have a const and/or volatile qualifier. All
 * other types result in `value` being `false`.
 * 
 * @tparam T possible integral type with optional const/volatile qualifiers
 * @param value `true` if `T` is an integral type with optional const/volatile
 * qualifiers; `false` otherwise
 */
template <typename T>
struct is_integral : public __is_integral<remove_cv_t<T>>::type {};

/**
 * @brief `True` if `T` is an integral type with optional const/volatile
 * qualifiers; otherwise, `false`.
 * 
 * @tparam T possible integral type with optional const/volatile qualifiers
 */
template <typename T>
inline constexpr bool is_integral_v = is_integral<T>::value;

template <typename T>
struct __is_floating_point : public false_type {};

template <>
struct __is_floating_point<float> : public true_type {};

template <>
struct __is_floating_point<double> : public true_type {};

template <>
struct __is_floating_point<long double> : public true_type {};

/**
 * @brief If `T` is a floating-point type with optional const/volatile
 * qualifiers, then `value` is `true`. Otherwise, `value` is `false`.
 *
 * @details
 * The types considered floating-point that result in `value` being `true` are:
 *
 * - `float`
 * - `double`
 * - `long double`
 *
 * Any of these types may also have a const and/or volatile qualifier. All
 * other types result in `value` being `false`.
 * 
 * @tparam T possible floating-point type with optional const/volatile
 * qualifiers
 * @param value `true` if `T` is a floating-point type with optional const/
 * volatile qualifiers; `false` otherwise
 */
template <typename T>
struct is_floating_point : public __is_floating_point<remove_cv_t<T>>::type {};

/**
 * @brief `True` if `T` is a floating-point type with optional const/volatile
 * qualifiers; otherwise, `false`.
 * 
 * @tparam T possible floating-point type with optional const/volatile
 * qualifiers
 */
template <typename T>
inline constexpr bool is_floating_point_v = is_floating_point<T>::value;

template <typename T>
struct __is_member_pointer : public false_type {};

template <typename T, typename U>
struct __is_member_pointer<T U::*> : public true_type {};

/**
 * @brief If `T` is a pointer to a non-static member object/function, then
 * `value` is `true`. Otherwise, `value` is `false`.
 *
 * @details
 * Valid types may also have a const and/or volatile qualifier. All other types
 * result in `value` being `false`.
 * 
 * @tparam T possible pointer type to a non-static member object/function with
 * optional const/volatile qualifiers
 * @param value `true` if `T` is a pointer type to a non-static member object/
 * function with optional const/volatile qualifiers; `false` otherwise
 */
template <typename T>
struct is_member_pointer : public __is_member_pointer<remove_cv_t<T>>::type {};

/**
 * @brief `True` if `T` is a pointer type to a non-static member object/
 * function with optional const/volatile qualifiers; otherwise, `false`.
 * 
 * @tparam T possible pointer type to a non-static member object/function with
 * optional const/volatile qualifiers
 */
template <typename T>
inline constexpr bool is_member_pointer_v = is_member_pointer<T>::value;

/**
 * @brief If `T` and `U` are the same type (taking into account const/volatile
 * qualifications), then `value` is `true`. Otherwise, `value` is `false`.
 *
 * @details
 * Commutativity is satisfied; i.e. for any two types `T` and `U`, the
 * following must hold:
 *   is_same<T, U>::value == is_same<U, T>::value
 * 
 * @tparam T type with optional const/volatile qualifiers
 * @tparam U type with optional const/volatile qualifiers
 * @param value `true` if `T` and `U` are the same type, taking into account
 * const/volatile qualifications; `false` otherwise
 */
template<typename T, typename U>
struct is_same : public false_type {};
 
 /**
 * @brief If `T` and `U` are the same type (taking into account const/volatile
 * qualifications), then `value` is `true`. Otherwise, `value` is `false`.
 *
 * @details
 * Commutativity is satisfied; i.e. for any two types `T` and `U`, the
 * following must hold:
 *   is_same<T, U>::value == is_same<U, T>::value
 * 
 * @tparam T type with optional const/volatile qualifiers
 * @tparam U type with optional const/volatile qualifiers
 * @param value `true` if `T` and `U` are the same type, taking into account
 * const/volatile qualifications; `false` otherwise
 */
template<typename T>
struct is_same<T, T> : std::true_type {};

/**
 * @brief `True` if `T` and `U` are the same type, taking into account const/
 * volatile qualifications; otherwise, `false`.
 * 
 * @tparam T type with optional const/volatile qualifiers
 * @tparam U type with optional const/volatile qualifiers
 */
template <typename T, typename U>
inline constexpr bool is_same_v = is_same<T, U>::value;

}; // namespace std

#endif // _STD_TYPE_TRAITS_HPP