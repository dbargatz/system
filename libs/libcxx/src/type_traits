/**
 * @file
 * @brief Implementations of compile-time template-based interfaces to query
 * various properties of types at compile-time; also known as metaprogramming.
 * 
 * @note Some comments and implementations in this file were based off of or
 * taken directly from the descriptions on
 * https://en.cppreference.com/w/cpp/header/type_traits and various subpages.
 * All errors are mine, all credit is theirs.
 */
#ifndef _STD_TYPE_TRAITS_HPP
#define _STD_TYPE_TRAITS_HPP

#include <cstddef>

namespace std {

/**
 * @brief Provides the member `type` with value `T`. Also known as the identity
 * transformation.
 * 
 * @tparam T type to set member `type` to
 */
template <typename T>
struct type_identity { using type = T; };

/**
 * @brief Wraps a static constant `v` of given type `T`. Serves as the base
 * class for all C++ type traits.
 * 
 * @details
 * Generally used to implement other type traits, but not useful on its own
 * otherwise.
 * 
 * @tparam T type of the constant
 * @tparam v value of the constant
 */
template <typename T, T v>
struct integral_constant {
    constexpr static T value = v;
    using value_type = T;
    using type = integral_constant;

    constexpr operator value_type() const noexcept { return value; }
    constexpr value_type operator ()() const noexcept { return value; }
};

/**
 * @brief Helper alias template for the common case where `T` is bool; in
 * other words, defines `std::integral_constant<bool, v>`, where `v` is either
 * `true` or `false`.
 * 
 * @see std::false_type
 * @see std::true_type
 * 
 * @tparam v `true` or `false`
 */
template <bool v>
using bool_constant = integral_constant<bool, v>;

/**
 * @brief Helper for the common case where `T` is `bool` and `v` is `false`; in
 * other words, defines `std::integral_constant<bool, false>`.
 */
using false_type = bool_constant<false>;

/**
 * @brief Helper for the common case where `T` is `bool` and `v` is `true`; in
 * other words, defines `std::integral_constant<bool, true`>`.
 */
using true_type  = bool_constant<true>;

/**
 * @brief If `B` is `true` at compile-time, then member `type` is `T`.
 * Otherwise, `type` is `F`.
 *
 * @tparam B compile-time boolean value which is `true` or `false`
 * @tparam T type to set member `type` to if `B` is `true`
 * @tparam F type to set member `type` to if `B` is `false`
 * @param type `T` if `B` is `true`; otherwise, `F`
 */
template <bool B, typename T, typename F>
struct conditional { using type = T; };

/**
 * @brief If `B` is `true` at compile-time, then member `type` is `T`.
 * Otherwise, `type` is `F`.
 *
 * @tparam B compile-time boolean value which is `true` or `false`
 * @tparam T type to set member `type` to if `B` is `true`
 * @tparam F type to set member `type` to if `B` is `false`
 * @param type `T` if `B` is `true`; otherwise, `F`
 */
template <typename T, typename F>
struct conditional<false, T, F> { using type = F; };

/**
 * @brief `T` if `B` is `true` at compile-time; otherwise, `F`.
 * 
 * @tparam B compile-time boolean value which is `true` or `false`
 * @tparam T type if `B` is `true`
 * @tparam F type if `B` is `false`
 */
template <bool B, typename T, typename F>
using conditional_t = typename conditional<B,T,F>::type;

/**
 * @brief If `B` is `true` at compile-time, then member `type` is `T`.
 * Otherwise, `type` is not defined.
 *
 * @tparam B compile-time boolean value which is `true` or `false`
 * @tparam T type to set member `type` to if `B` is `true`
 * @param type `T` if `B` is `true`; otherwise, not defined
 */
template <bool B, typename T = void>
struct enable_if {};

/**
 * @brief If `B` is `true` at compile-time, then member `type` is `T`.
 * Otherwise, `type` is not defined.
 *
 * @tparam B compile-time boolean value which is `true` or `false`
 * @tparam T type to set member `type` to if `B` is `true`
 * @param type `T` if `B` is `true`; otherwise, not defined
 */
template <typename T>
struct enable_if<true, T> { using type = T; };

/**
 * @brief `T` if `B` is `true` at compile-time; otherwise, not defined.
 * 
 * @tparam B compile-time boolean value which is `true` or `false`
 * @tparam T type if `B` is `true`
 */
template <bool B, typename T = void>
using enable_if_t = typename enable_if<B,T>::type;

/**
 * @brief If `T` is an array type, member `value` is `true`; otherwise, member
 * `value` is `false`.
 * 
 * @tparam T possible array type
 */
template <typename T>
struct is_array : false_type {};

/**
 * @brief If `T` is an array type, member `value` is `true`; otherwise, member
 * `value` is `false`.
 * 
 * @tparam T possible array type
 */
template <typename T>
struct is_array<T[]> : true_type {};

/**
 * @brief If `T` is an array type, member `value` is `true`; otherwise, member
 * `value` is `false`.
 * 
 * @tparam T possible array type
 */
template <typename T, size_t N>
struct is_array<T[N]> : true_type {};

/**
 * @brief `True` if `T` is an array type; otherwise, `false`.
 * 
 * @tparam T possible array type
 */
template <typename T>
inline constexpr bool is_array_v = is_array<T>::value;

/**
 * @brief If `T` is a const-qualified type, member `value` is `true`; otherwise,
 * member `value` is `false`.
 * 
 * @tparam T possible const-qualified type
 */
template <typename T>
struct is_const : false_type {};

/**
 * @brief If `T` is a const-qualified type, member `value` is `true`; otherwise,
 * member `value` is `false`.
 * 
 * @tparam T possible const-qualified type
 */
template <typename T>
struct is_const<const T> : true_type {};

/**
 * @brief `True` if `T` is a const-qualified type; otherwise, `false`.
 * 
 * @tparam T possible const-qualified type
 */
template <typename T>
inline constexpr bool is_const_v = is_const<T>::value;

/**
 * @brief If `T` is an lvalue reference type, member `value` is `true`.
 * Otherwise, member `value` is `false`.
 * 
 * @tparam T possible lvalue reference type
 */
template <typename T>
struct is_lvalue_reference : false_type {};

/**
 * @brief If `T` is an lvalue reference type, member `value` is `true`.
 * Otherwise, member `value` is `false`.
 * 
 * @tparam T possible lvalue reference type
 */
template <typename T>
struct is_lvalue_reference<T&> : true_type {};

/**
 * @brief `True` if `T` is an lvalue reference type; otherwise, `false`.
 * 
 * @tparam T possible lvalue reference type
 */
template <typename T>
inline constexpr bool is_lvalue_reference_v = is_lvalue_reference<T>::value;

/**
 * @brief If `T` is an lvalue reference type or rvalue reference type, member
 * `value` is `true`. Otherwise, member `value` is `false`.
 * 
 * @tparam T possible lvalue reference or rvalue reference type
 */
template <typename T>
struct is_reference : false_type {};

/**
 * @brief If `T` is an lvalue reference type or rvalue reference type, member
 * `value` is `true`. Otherwise, member `value` is `false`.
 * 
 * @tparam T possible lvalue reference or rvalue reference type
 */
template <typename T>
struct is_reference<T&> : true_type {};

/**
 * @brief If `T` is an lvalue reference type or rvalue reference type, member
 * `value` is `true`. Otherwise, member `value` is `false`.
 * 
 * @tparam T possible lvalue reference or rvalue reference type
 */
template <typename T>
struct is_reference<T&&> : true_type {};

/**
 * @brief `True` if `T` is an lvalue reference type or rvalue reference type;
 * otherwise, `false`.
 * 
 * @tparam T possible lvalue reference or rvalue reference type
 */
template <typename T>
inline constexpr bool is_reference_v = is_reference<T>::value;

/**
 * @brief If `T` is an rvalue reference type, member `value` is `true`.
 * Otherwise, member `value` is `false`.
 * 
 * @tparam T possible rvalue reference type
 */
template <typename T>
struct is_rvalue_reference : false_type {};

/**
 * @brief If `T` is an rvalue reference type, member `value` is `true`.
 * Otherwise, member `value` is `false`.
 * 
 * @tparam T possible rvalue reference type
 */
template <typename T>
struct is_rvalue_reference<T&&> : true_type {};

/**
 * @brief `True` if `T` is an rvalue reference type; otherwise, `false`.
 * 
 * @tparam T possible rvalue reference type
 */
template <typename T>
inline constexpr bool is_rvalue_reference_v = is_rvalue_reference<T>::value;

/**
 * @brief Removes the topmost const qualifier and/or the topmost volatile
 * qualifier (if any) from the given type.
 * 
 * @tparam T type with possible const/volatile qualifiers
 * @param type type with topmost const/volatile qualifiers removed (if any) 
 */
template <typename T>
struct remove_cv { typedef T type; };

/**
 * @brief Removes the topmost const qualifier and/or the topmost volatile
 * qualifier (if any) from the given type.
 * 
 * @tparam T type with possible const/volatile qualifiers
 * @param type type with topmost const/volatile qualifiers removed (if any) 
 */
template <typename T>
struct remove_cv<const T> { typedef T type; };

/**
 * @brief Removes the topmost const qualifier and/or the topmost volatile
 * qualifier (if any) from the given type.
 * 
 * @tparam T type with possible const/volatile qualifiers
 * @param type type with topmost const/volatile qualifiers removed (if any) 
 */
template <typename T>
struct remove_cv<volatile T> { typedef T type; };

/**
 * @brief Removes the topmost const qualifier and/or the topmost volatile
 * qualifier (if any) from the given type.
 * 
 * @tparam T type with possible const/volatile qualifiers
 * @param type type with topmost const/volatile qualifiers removed (if any) 
 */
template <typename T>
struct remove_cv<const volatile T> { typedef T type; };

/**
 * @brief Type with the topmost const qualifier and/or the topmost volatile
 * qualifier removed (if any).
 * 
 * @tparam T type with possible const/volatile qualifiers
 */
template <typename T>
using remove_cv_t = typename remove_cv<T>::type;
 
/**
 * @brief Removes the topmost const qualifier (if any) from the given type.
 * 
 * @tparam T type with possible const qualifier
 * @param type type with topmost const qualifier removed (if any)
 */
template <typename T>
struct remove_const { typedef T type; };

 /**
 * @brief Removes the topmost const qualifier (if any) from the given type.
 * 
 * @tparam T type with possible const qualifier
 * @param type type with topmost const qualifier removed (if any)
 */
template <typename T>
struct remove_const<const T> { typedef T type; };

/**
 * @brief Type with the topmost const qualifier removed (if any).
 * 
 * @tparam T type with possible const qualifier
 */
template <typename T>
using remove_const_t = typename remove_const<T>::type;

/**
 * @brief If `T` is an array of some type `X`, member `type` is equal to `X`;
 * otherwise, member `type` is `T`.
 * 
 * @note If `T` is a multidimensional array, only the first dimension is
 * removed.
 * 
 * @tparam T possible array type
 */
template <typename T>
struct remove_extent { using type = T; };

/**
 * @brief If `T` is an array of some type `X`, member `type` is equal to `X`;
 * otherwise, member `type` is `T`.
 * 
 * @note If `T` is a multidimensional array, only the first dimension is
 * removed.
 * 
 * @tparam T possible array type
 */
template <typename T>
struct remove_extent<T[]> { using type = T; };

/**
 * @brief If `T` is an array of some type `X`, member `type` is equal to `X`;
 * otherwise, member `type` is `T`.
 * 
 * @note If `T` is a multidimensional array, only the first dimension is
 * removed.
 * 
 * @tparam T possible array type
 */
template <typename T, size_t N>
struct remove_extent<T[N]> { using type = T; };

/**
 * @brief `X` if `T` is an array of some type `X`; otherwise, `T`.
 * 
 * @note If `T` is a multidimensional array, only the first dimension is
 * removed.
 * 
 * @tparam T possible array type
 */
template <typename T>
using remove_extent_t = typename remove_extent<T>::type;

/**
 * @brief Removes the topmost volatile qualifier (if any) from the given type.
 * 
 * @tparam T type with possible volatile qualifier
 * @param type type with topmost volatile qualifier removed (if any)
 */
template <typename T>
struct remove_volatile { typedef T type; };

/**
 * @brief Removes the topmost volatile qualifier (if any) from the given type.
 * 
 * @tparam T type with possible volatile qualifier
 * @param type type with topmost volatile qualifier removed (if any)
 */
template <typename T>
struct remove_volatile<volatile T> { typedef T type; };

/**
 * @brief Type `T` with the topmost volatile qualifier removed (if any).
 * 
 * @tparam T type with possible volatile qualifier
 */
template <typename T>
using remove_volatile_t = typename remove_volatile<T>::type;

/**
 * @brief If the type `T` is a reference type, member `type` is equal to the
 * type referred to by T. If the type T is not a reference type, member `type`
 * is equal to `T`.
 *
 * @tparam T possible reference type
 * @param type the type referred to by `T`, or `T`
 */
template <typename T>
struct remove_reference { typedef T type; };

/**
 * @brief If the type `T` is a reference type, member `type` is equal to the
 * type referred to by T. If the type T is not a reference type, member `type`
 * is equal to `T`.
 *
 * @tparam T possible reference type
 * @param type the type referred to by `T`, or `T`
 */
template <typename T>
struct remove_reference<T&> { typedef T type; };

/**
 * @brief If the type `T` is a reference type, member `type` is equal to the
 * type referred to by T. If the type T is not a reference type, member `type`
 * is equal to `T`.
 *
 * @tparam T possible reference type
 * @param type the type referred to by `T`, or `T`
 */
template <typename T>
struct remove_reference<T&&> { typedef T type; };

/**
 * @brief Underlying type that `T` is referring to, or `T` if `T` is not a
 * reference type.
 * 
 * @tparam T possible reference type
 */
template <typename T>
using remove_reference_t = typename remove_reference<T>::type;

template <typename T>
auto __add_lvalue_reference(int) -> type_identity<T&>;

template <typename T>
auto __add_lvalue_reference(...) -> type_identity<T>;

/**
 * @brief If `T` is an object type or a function type without const, volatile,
 * or reference qualifiers, member `type` has value `T&`. If `T` is an rvalue
 * reference to some type `U`, member `type` has value `U&`. Otherwise, member
 * `type` has value `T`.
 *
 * @tparam T type to add lvalue reference to
 * @param type reference to `T`, or `T` if not allowed
 */
template <typename T>
struct add_lvalue_reference : decltype(__add_lvalue_reference<T>(0)) {};

/**
 * @brief `T&` if `T` is an object type or a function type without const,
 * volatile, or reference qualifiers. `U&` if `T` is an rvalue reference to
 * some type `U`. Otherwise, `T`.
 *
 * @tparam T type to add lvalue reference to
 */
template <typename T>
using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;

template <typename T>
auto __add_rvalue_reference(int) -> type_identity<T&&>;

template <typename T>
auto __add_rvalue_reference(...) -> type_identity<T>;

/**
 * @brief If `T` is an object type or a function type without const, volatile,
 * or reference qualifiers, member `type` has value `T&&`; otherwise, member
 * `type` has value `T`.
 *
 * @tparam T type to add rvalue reference to
 * @param type reference to `T`, or `T` if not allowed
 */
template <typename T>
struct add_rvalue_reference : decltype(__add_rvalue_reference<T>(0)) {};

/**
 * @brief `T&&` if `T` is an object type or a function type without const,
 * volatile, or reference qualifiers; otherwise, `T`.
 *
 * @tparam T type to add rvalue reference to
 */
template <typename T>
using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;

template <typename T>
auto __add_pointer(int) -> type_identity<typename remove_reference<T>::type * >;

template <typename T>
auto __add_pointer(...) -> type_identity<T>;

/**
 * @brief If `T` is a reference type to `X`, member `type` has value `X*` (a
 * pointer to `X`). If `T` is an object type or a function type without const,
 * volatile, or reference qualifiers, member `type` has value `T*` (a pointer
 * to `T`). Otherwise, `T` must be a function type with const, volatile, and/or
 * reference qualifiers, so member `type` has value `T`.
 *
 * @tparam T type to add pointer to
 * @param type pointer to `X` where `T` is a reference type to `X`, or a
 * pointer to `T`, or `T`
 */
template <typename T>
struct add_pointer : decltype(__add_pointer<T>(0)) {};

/**
 * @brief `X*` if `T` is a reference type to `X`; `T*` if `T` is an object type
 * or a function type without const, volatile, or reference qualifiers;
 * otherwise, `T`.
 *
 * @tparam T type to add pointer to
 */
template <typename T>
using add_pointer_t = typename add_pointer<T>::type;

template <typename T>
struct __is_void : public false_type {};

template <>
struct __is_void<void> : public true_type {};

/**
 * @brief If `T` is a `void` type with optional const/volatile qualifiers, then
 * `value` is `true`. Otherwise, `value` is `false`.
 *
 * @details
 * The types considered void that result in `value` being `true` are:
 *
 * - `void`
 * - `const void`
 * - `volatile void`
 * - `const volatile void`
 *
 * All other types result in `value` being `false`.
 * 
 * @tparam T possible void type with optional const/volatile qualifiers
 * @param value `true` if `T` is a void type with optional const/volatile
 * qualifiers; `false` otherwise
 */
template <typename T>
struct is_void : public __is_void<remove_cv_t<T>>::type {};

/**
 * @brief `True` if `T` is a void type with optional const/volatile qualifiers;
 * otherwise, `false`.
 * 
 * @tparam T possible void type with optional const/volatile qualifiers
 */
template <typename T>
inline constexpr bool is_void_v = is_void<T>::value;

template <typename T>
struct __is_null_pointer : public false_type {};

template <>
struct __is_null_pointer<nullptr_t> : public true_type {};

/**
 * @brief If `T` is the `std::nullptr_t` type with optional const/volatile
 * qualifiers, then `value` is `true`. Otherwise, `value` is `false`.
 *
 * @details
 * The types considered `std::nullptr_t` that result in `value` being `true`
 * are:
 *
 * - `std::nullptr_t`
 * - `const std::nullptr_t`
 * - `volatile std::nullptr_t`
 * - `const volatile std::nullptr_t`
 *
 * All other types result in `value` being `false`.
 * 
 * @tparam T possible `std::nullptr_t` type with optional const/volatile
 * qualifiers
 * @param value `true` if `T` is the `std::nullptr_t` type with optional const/
 * volatile qualifiers; `false` otherwise
 */
template <typename T>
struct is_null_pointer : public __is_null_pointer<remove_cv_t<T>>::type {};

/**
 * @brief `True` if `T` is the `std::nullptr_t` type with optional const/
 * volatile qualifiers; otherwise, `false`.
 * 
 * @tparam T possible `std::nullptr_t` type with optional const/volatile
 * qualifiers
 */
template <typename T>
inline constexpr bool is_null_pointer_v = is_null_pointer<T>::value;

/**
 * @brief If `T` is a function type, member `value` is `true`; otherwise,
 * member `value` is `false`.
 * 
 * @note Lambdas, classes with `operator()` overloaded, pointers to functions,
 * and `std::function` do not count as functions for the purposes of this type
 * check.
 * 
 * @tparam T possible function type (see note)
 */
template <typename T>
struct is_function : integral_constant<bool, !is_const<const T>::value && !is_reference<T>::value> {};

/**
 * @brief `True` if `T` is a function type; otherwise, `false`.
 * 
 * @note Lambdas, classes with `operator()` overloaded, pointers to functions,
 * and `std::function` do not count as functions for the purposes of this type
 * check.
 * 
 * @tparam T possible function type (see note)
 */
template <typename T>
inline constexpr bool is_function_v = is_function<T>::value;

template <typename T>
struct __is_integral : public false_type {};

template <>
struct __is_integral<bool> : public true_type {};

template <>
struct __is_integral<char> : public true_type {};

template <>
struct __is_integral<signed char> : public true_type {};

template <>
struct __is_integral<unsigned char> : public true_type {};

template <>
struct __is_integral<char8_t> : public true_type {};

template <>
struct __is_integral<char16_t> : public true_type {};

template <>
struct __is_integral<char32_t> : public true_type {};

template <>
struct __is_integral<wchar_t> : public true_type {};

template <>
struct __is_integral<short> : public true_type {};

template <>
struct __is_integral<unsigned short> : public true_type {};

template <>
struct __is_integral<int> : public true_type {};

template <>
struct __is_integral<unsigned int> : public true_type {};

template <>
struct __is_integral<long> : public true_type {};

template <>
struct __is_integral<unsigned long> : public true_type {};

template <>
struct __is_integral<long long> : public true_type {};

template <>
struct __is_integral<unsigned long long> : public true_type {};

/**
 * @brief If `T` is an integral type with optional const/volatile qualifiers,
 * then `value` is `true`. Otherwise, `value` is `false`.
 *
 * @details
 * The types considered integral that result in `value` being `true` are:
 *
 * - `bool`
 * - `char` (signed, unsigned, or unspecified)
 * - `char8_t`
 * - `char16_t`
 * - `char32_t`
 * - `wchar_t`
 * - `short` (signed, unsigned, or unspecified)
 * - `int` (signed, unsigned, or unspecified)
 * - `long` (signed, unsigned, or unspecified)
 * - `long long` (signed, unsigned, or unspecified)
 *
 * Any of these types may also have a const and/or volatile qualifier. All
 * other types result in `value` being `false`.
 * 
 * @tparam T possible integral type with optional const/volatile qualifiers
 * @param value `true` if `T` is an integral type with optional const/volatile
 * qualifiers; `false` otherwise
 */
template <typename T>
struct is_integral : public __is_integral<remove_cv_t<T>>::type {};

/**
 * @brief `True` if `T` is an integral type with optional const/volatile
 * qualifiers; otherwise, `false`.
 * 
 * @tparam T possible integral type with optional const/volatile qualifiers
 */
template <typename T>
inline constexpr bool is_integral_v = is_integral<T>::value;

template <typename T>
struct __is_floating_point : public false_type {};

template <>
struct __is_floating_point<float> : public true_type {};

template <>
struct __is_floating_point<double> : public true_type {};

template <>
struct __is_floating_point<long double> : public true_type {};

/**
 * @brief If `T` is a floating-point type with optional const/volatile
 * qualifiers, then `value` is `true`. Otherwise, `value` is `false`.
 *
 * @details
 * The types considered floating-point that result in `value` being `true` are:
 *
 * - `float`
 * - `double`
 * - `long double`
 *
 * Any of these types may also have a const and/or volatile qualifier. All
 * other types result in `value` being `false`.
 * 
 * @tparam T possible floating-point type with optional const/volatile
 * qualifiers
 * @param value `true` if `T` is a floating-point type with optional const/
 * volatile qualifiers; `false` otherwise
 */
template <typename T>
struct is_floating_point : public __is_floating_point<remove_cv_t<T>>::type {};

/**
 * @brief `True` if `T` is a floating-point type with optional const/volatile
 * qualifiers; otherwise, `false`.
 * 
 * @tparam T possible floating-point type with optional const/volatile
 * qualifiers
 */
template <typename T>
inline constexpr bool is_floating_point_v = is_floating_point<T>::value;

template <typename T>
struct __is_member_pointer : public false_type {};

template <typename T, typename U>
struct __is_member_pointer<T U::*> : public true_type {};

/**
 * @brief If `T` is a pointer to a non-static member object/function, then
 * `value` is `true`. Otherwise, `value` is `false`.
 *
 * @details
 * Valid types may also have a const and/or volatile qualifier. All other types
 * result in `value` being `false`.
 * 
 * @tparam T possible pointer type to a non-static member object/function with
 * optional const/volatile qualifiers
 * @param value `true` if `T` is a pointer type to a non-static member object/
 * function with optional const/volatile qualifiers; `false` otherwise
 */
template <typename T>
struct is_member_pointer : public __is_member_pointer<remove_cv_t<T>>::type {};

/**
 * @brief `True` if `T` is a pointer type to a non-static member object/
 * function with optional const/volatile qualifiers; otherwise, `false`.
 * 
 * @tparam T possible pointer type to a non-static member object/function with
 * optional const/volatile qualifiers
 */
template <typename T>
inline constexpr bool is_member_pointer_v = is_member_pointer<T>::value;

/**
 * @brief If `T` and `U` are the same type (taking into account const/volatile
 * qualifications), then `value` is `true`. Otherwise, `value` is `false`.
 *
 * @details
 * Commutativity is satisfied; i.e. for any two types `T` and `U`, the
 * following must hold:
 *   is_same<T, U>::value == is_same<U, T>::value
 * 
 * @tparam T type with optional const/volatile qualifiers
 * @tparam U type with optional const/volatile qualifiers
 * @param value `true` if `T` and `U` are the same type, taking into account
 * const/volatile qualifications; `false` otherwise
 */
template<typename T, typename U>
struct is_same : public false_type {};
 
 /**
 * @brief If `T` and `U` are the same type (taking into account const/volatile
 * qualifications), then `value` is `true`. Otherwise, `value` is `false`.
 *
 * @details
 * Commutativity is satisfied; i.e. for any two types `T` and `U`, the
 * following must hold:
 *   is_same<T, U>::value == is_same<U, T>::value
 * 
 * @tparam T type with optional const/volatile qualifiers
 * @tparam U type with optional const/volatile qualifiers
 * @param value `true` if `T` and `U` are the same type, taking into account
 * const/volatile qualifications; `false` otherwise
 */
template<typename T>
struct is_same<T, T> : std::true_type {};

/**
 * @brief `True` if `T` and `U` are the same type, taking into account const/
 * volatile qualifications; otherwise, `false`.
 * 
 * @tparam T type with optional const/volatile qualifiers
 * @tparam U type with optional const/volatile qualifiers
 */
template <typename T, typename U>
inline constexpr bool is_same_v = is_same<T, U>::value;

}; // namespace std

#endif // _STD_TYPE_TRAITS_HPP