/**
 * @file
 * @brief Implementations of compile-time template-based interfaces to query
 * various properties of types at compile-time, as defined by C++20 (N4849
 * draft) sections 20.15. Also known as metaprogramming.
 * 
 * @note Some comments and implementations in this file were based off of or
 * taken directly from the descriptions on
 * https://en.cppreference.com/w/cpp/header/type_traits and various subpages.
 * All errors are mine, all credit is theirs.
 */
#ifndef _STD_TYPE_TRAITS_HPP
#define _STD_TYPE_TRAITS_HPP

#include <__type_traits/__array_modifications.hpp>
#include <__type_traits/__composite_categories.hpp>
#include <__type_traits/__cv_modifications.hpp>
#include <__type_traits/__decay.hpp>
#include <__type_traits/__helpers.hpp>
#include <__type_traits/__is_reference.hpp>
#include <__type_traits/__misc_transformations.hpp>
#include <__type_traits/__pointer_modifications.hpp>
#include <__type_traits/__primary_categories.hpp>
#include <__type_traits/__properties.hpp>
#include <__type_traits/__reference_modifications.hpp>
#include <__type_traits/__relationships.hpp>
#include <__type_traits/__supported_operations.hpp>
#include <__type_traits/__trait_operations.hpp>

// UNIMPLEMENTED TRAITS:
// __type_traits/__constant_eval.hpp_________________________________________________
// constexpr bool is_constant_evaluated() noexcept;
// __type_traits/__member_relationships.hpp_________________________________________________
// template<class S, class M>
// constexpr bool is_pointer_interconvertible_with_class(M S::*m) noexcept;
// template<class S1, class S2, class M1, class M2>
// constexpr bool is_corresponding_member(M1 S1::*m1, M2 S2::*m2) noexcept;
// __type_traits/__property_queries.hpp_________________________________________________
// template<class T> struct alignment_of;
// template<class T> struct rank;
// template<class T, unsigned I = 0> struct extent;
// template<class T>
// inline constexpr size_t alignment_of_v = alignment_of<T>::value;
// template<class T>
// inline constexpr size_t rank_v = rank<T>::value;
// template<class T, unsigned I = 0>
// inline constexpr size_t extent_v = extent<T, I>::value;
// __type_traits/__sign_modifiers.hpp_________________________________________________
// template<class T> struct make_signed;
// template<class T> struct make_unsigned;
// template<class T>
// using make_signed_t   = typename make_signed<T>::type;
// template<class T>
// using make_unsigned_t = typename make_unsigned<T>::type;

#endif // _STD_TYPE_TRAITS_HPP