#ifndef _STD_FORMAT_HPP
#define _STD_FORMAT_HPP

#include <cassert>
#include <cstdint>
#include <string>
#include <utility>

namespace std {

template <typename T>
struct formatter {
    formatter() = delete;
};

template <>
struct formatter<uint64_t> {
public:
    formatter() { }

    void parse(const string::value_type* in_open_brace,
               const string::value_type* in_close_brace) {
        bool alternate_form = false;

        // Advance to the colon separating the argument index from the format
        // args. Argument indices are currently not supported.
        const string::value_type* ptr = in_open_brace;
        while(++ptr != in_close_brace) {
            if(*ptr == ':') {
                ptr++;
                break;
            }
        }

        // If there's no colon between the open and close braces, or the colon
        // is followed immediately by the closing brace, use default values for
        // all format args.
        if(ptr == in_close_brace) { return; }

        // Handle the fill-and-align character (if present).
        switch(*ptr) {
            case '<':
                _fill_and_align = *ptr++;
                break;
            case '^':
                _fill_and_align = *ptr++;
                break;
            case '>':
                // As right-alignment is the default alignment for integers and
                // floats, fall through to the default case.
                ptr++;
            default:
                break;
        }

        // Handle the sign character (if present).
        switch(*ptr) {
            case '+':
                _sign = *ptr++;
                break;
            case ' ':
                _sign = *ptr++;
                break;
            case '-':
                // As prefixing only negative numbers is the default behavior,
                // fall through to the default case.
                ptr++;
            default:
                break;
        }

        // Handle the alternate form character (if present).
        if(*ptr == '#') {
            alternate_form = true;
            ptr++;
        }

        // Handle the zero-padding character (if present).
        if(*ptr == '0') {
            _fill_char = "0";
            ptr++;
        }

        // Handle the width field (if present). Note that nested replacement
        // fields are currently not handled.
        while(*ptr >= '0' && *ptr <= '9') {
            _min_width = (_min_width * 10) + (*ptr - '0');
            ptr++;
        }

        // Note that the locale-specific character option (L) is not currently
        // handled.

        // Handle the type field (if present).
        switch(*ptr) {
            case 'b':
            case 'B':
                _base = 2;
                if(alternate_form) {
                    _prefix = "0b";
                }
                break;
            case 'o':
            case 'O':
                _base = 8;
                if(alternate_form) {
                    _prefix = "0";
                }
                break;
            case 'x':
                _digits = _hex_lower;
            case 'X':
                _base = 16;
                if(alternate_form) {
                    _prefix = "0x";
                }
                break;
            case 'd':
                // As a base-10 integer is the default case, fall through to
                // the default case.
            default:
                _base = 10;
                break;
        }
    }

    string format(const uint64_t& in_arg) {
        auto str = string("");
        uint64_t remainder = in_arg;

        if(0 == remainder) {
            str.append(&(_digits[0]), 1);
        }
        else {
            while(remainder != 0) {
                str.append(&(_digits[remainder % _base]), 1);
                remainder /= _base;
            }
        }

        // If the number of digits is less than the minimum field width, append the
        // fill character until reaching the minimum field width. Note that this 
        // effectively right-aligns the number, as the temp buffer is in reverse
        // order.
        while(str.size() < _min_width) {
            str.append(_fill_char, 1);
        }

        auto new_str = string(_prefix);
        for(int64_t i = str.size()-1; i >= 0; i--) {
            auto ptr = &(str.data()[i]);
            new_str.append(ptr, 1);
        }

        return new_str;
    }

private:
    static constexpr char _hex_upper[] = "0123456789ABCDEF";
    static constexpr char _hex_lower[] = "0123456789abcdef";

    uint8_t      _base           = 10;
    const char * _digits         = _hex_upper;
    char         _fill_and_align = '>';
    const char * _fill_char      = " ";
    uint8_t      _min_width      = 0;
    const char * _prefix         = "";
    char         _sign           = '-';
};

template <>
struct formatter<char> {
public:
    formatter() { }

    void parse(const string::value_type * in_open_brace,
               const string::value_type * in_close_brace) {
        // TODO: Figure out format spec for characters
        _fill_char = " ";
        _min_width = 16;
    }

    string format(const char8_t& in_arg) {
        auto str = string("");
        str.append(in_arg);
        return str;
    }

private:
    const char * _fill_char;
    uint8_t      _min_width;
};

template <>
struct formatter<const char*> {
public:
    formatter() { }

    void parse(const string::value_type* in_open_brace,
               const string::value_type* in_close_brace) {
        // TODO: choose all these based on parsed spec
        _fill_char = " ";
        _min_width = 16;
    }

    string format(const char* in_arg) {
        auto str = string("");
        while(*in_arg != '\0') {
            str.append(in_arg, 1);
            in_arg++;
        }

        // TODO: fill out to minimum width

        return str;
    }

private:
    const char * _fill_char;
    uint8_t      _min_width;
};

template <>
struct formatter<const char8_t*> {
public:
    formatter() { }

    void parse(const string::value_type* in_open_brace,
               const string::value_type* in_close_brace) {
        // TODO: choose all these based on parsed spec
        _fill_char = " ";
        _min_width = 16;
    }

    string format(const char8_t* in_arg) {
        auto str = string("");
        while(*in_arg != '\0') {
            str.append((const char *)in_arg, 1);
            in_arg++;
        }

        // TODO: fill out to minimum width

        return str;
    }

private:
    const char * _fill_char;
    uint8_t      _min_width;
};

template <>
struct formatter<string> {
public:
    formatter() { }

    void parse(const string::value_type* in_open_brace,
               const string::value_type* in_close_brace) {
        // TODO: choose all these based on parsed spec
        _fill_char = " ";
        _min_width = 16;
    }

    string format(const string& in_arg) {
        return string(in_arg);
    }

private:
    const char * _fill_char;
    uint8_t      _min_width;
};

template <>
struct formatter<const void *> : public formatter<uint64_t> {
    string format(const void* in_arg) {
        return formatter<uint64_t>::format((uint64_t)in_arg);
    }
};

template <>
struct formatter<uint8_t> : public formatter<uint64_t> {};

template <>
struct formatter<uint16_t> : public formatter<uint64_t> {};

template <>
struct formatter<uint32_t> : public formatter<uint64_t> {};

template <>
struct formatter<int8_t> : public formatter<uint64_t> {};

template <>
struct formatter<int16_t> : public formatter<uint64_t> {};

template <>
struct formatter<int32_t> : public formatter<uint64_t> {};

template <>
struct formatter<int64_t> : public formatter<uint64_t> {};

template <>
struct formatter<double> : public formatter<uint64_t> {};

template <>
struct formatter<bool> {
public:
    formatter() { }

    void parse(const string::value_type* in_open_brace,
               const string::value_type* in_close_brace) {
        // TODO: implement bool format spec
    }

    string format(const bool& in_arg) {
        return (in_arg ? string("true") : string("false"));
    }
};

template <typename... Args>
string format(const string& in_fmt) {
    return in_fmt;
}

template <typename T, typename... Args>
string format(const string& in_fmt, const T& in_arg, const Args&... in_args) {
    auto prefix = string("");
    const string::value_type* ptr = in_fmt.data();

    // Advance until we find an opening brace. We shouldn't encounter a null terminator, since
    // there are still args left to format if we're in this function.
    while(*ptr != '{') {
        assert(*ptr != '\0');
        if(*ptr == '{' && *(ptr + 1) != '{') {
            break;
        }
        prefix.append(ptr, 1);
        ptr++;
    }

    // Ptr is currently pointing at the opening brace for this format arg. Find
    // the closing brace. Note that escaped closing braces (the "}}" sequence)
    // can't appear in a format arg specification, thus the assert below the
    // loop.
    auto open_brace  = ptr;
    auto close_brace = ptr;
    while(*close_brace != '}') {
        assert(*close_brace != '\0');
        close_brace++;
    }
    assert(*close_brace == '}' && *(close_brace + 1) != '}');

    // We now have the open and close braces for this format arg specification.
    // Parse the specification between the braces using the appropriate
    // formatter for in_arg.
    auto fmt = formatter<T>();
    fmt.parse(open_brace, close_brace);

    // Format the current argument using the formatter.
    auto arg_str = fmt.format(in_arg);

    // Append the arg string to the current string.
    prefix.append(arg_str.data(), arg_str.size());

    // Continue formatting the string with the remaining args.
    auto suffix = format(string(close_brace + 1), in_args...);
    return prefix.append(suffix.data(), suffix.size());
}

}; // namespace std

#endif // _STD_FORMAT_HPP
