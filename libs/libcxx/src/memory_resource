#ifndef _STD_MEMORY_RESOURCE_HPP
#define _STD_MEMORY_RESOURCE_HPP

#include <cstddef>
#include <cstdint>
#include <new>

namespace std::pmr {

class memory_resource {
public:
    virtual ~memory_resource()  = default;

    void * allocate(std::size_t in_bytes, std::align_val_t in_alignment = std::align_val_t(alignof(std::max_align_t))) {
        return do_allocate(in_bytes, in_alignment);
    }

    void deallocate(void * in_ptr, std::size_t in_bytes, std::align_val_t in_alignment = std::align_val_t(alignof(std::max_align_t))) {
        return do_deallocate(in_ptr, in_bytes, in_alignment);
    }

    bool is_equal(memory_resource const& in_other) const noexcept {
        return do_is_equal(in_other);
    }

protected:
    virtual void * do_allocate(std::size_t in_bytes, std::align_val_t in_alignment) = 0;
    virtual void do_deallocate(void * in_ptr, std::size_t in_bytes, std::align_val_t in_alignment) = 0;
    virtual bool do_is_equal(memory_resource const& in_other) const noexcept = 0;
};

class new_delete_memory_resource : public memory_resource {
protected:
    void * do_allocate(std::size_t in_bytes, std::align_val_t in_alignment) {
        return ::operator new(in_bytes, in_alignment);
    }

    void do_deallocate(void * in_ptr, std::size_t in_bytes, std::align_val_t in_alignment) {
        ::operator delete(in_ptr, in_bytes, in_alignment);
    }

    bool do_is_equal(memory_resource const& in_other) const noexcept {
        return (this == &in_other);
    }
};

memory_resource* get_default_resource() noexcept;
memory_resource* new_delete_resource() noexcept;
memory_resource* set_default_resource(memory_resource* r) noexcept;

template <typename T = std::uint8_t>
class polymorphic_allocator {
public:
    using value_type = T;

    polymorphic_allocator() noexcept {
        _resource = get_default_resource();
    }

    polymorphic_allocator(const polymorphic_allocator& in_other) = default;

    template <typename U>
    polymorphic_allocator(const polymorphic_allocator<U>& in_other) noexcept :
        _resource(in_other.resource()) { }

    polymorphic_allocator(memory_resource * in_resource) : _resource(in_resource) {}

    [[nodiscard]] T* allocate(std::size_t in_num) const {
        return static_cast<T*>(resource()->allocate(in_num * sizeof(T), std::align_val_t(alignof(T))));
    }

    void deallocate(T* in_ptr, std::size_t in_num) const {
        resource()->deallocate(in_ptr, in_num * sizeof(T), std::align_val_t(alignof(T)));
    }

    memory_resource * resource() const {
        return _resource;
    }

private:
    memory_resource * _resource;
};

template <typename T1, typename T2>
bool operator== (const std::pmr::polymorphic_allocator<T1>& in_lhs,
                 const std::pmr::polymorphic_allocator<T2>& in_rhs) noexcept {
    return (*in_lhs.resource() == *in_rhs.resource());
}

class monotonic_buffer_resource : public memory_resource {
public:
    monotonic_buffer_resource(const monotonic_buffer_resource&) = delete;

    monotonic_buffer_resource() {
        _upstream = get_default_resource();
        _initial_buffer = nullptr;
        _initial_buffer_size = 0;
        _current_buffer = nullptr;
        _next_buffer_size = 32;
    }

    explicit monotonic_buffer_resource(memory_resource * in_upstream) : monotonic_buffer_resource() {
        _upstream = in_upstream;
    }

    explicit monotonic_buffer_resource(std::size_t in_initial_size) : monotonic_buffer_resource() {
        if(in_initial_size > _next_buffer_size) {
            _next_buffer_size = in_initial_size;
        }
    }

    monotonic_buffer_resource(std::size_t in_initial_size, memory_resource * in_upstream) : monotonic_buffer_resource(in_initial_size) {
        _upstream = in_upstream;
    }

    monotonic_buffer_resource(void * in_buffer, std::size_t in_buffer_size) : monotonic_buffer_resource() {
        _initial_buffer = (std::uint8_t *)in_buffer;
        _initial_buffer_size = in_buffer_size;
        _current_buffer = _initial_buffer;
        _next_buffer_size = in_buffer_size > 1 ? in_buffer_size : 1;
    }

    monotonic_buffer_resource(void * in_buffer, std::size_t in_buffer_size, memory_resource * in_upstream) : monotonic_buffer_resource(in_buffer, in_buffer_size) {
        _upstream = in_upstream;
    }

    void release() {
        if(_upstream != nullptr) {
            if(_current_buffer != _initial_buffer) {
                _upstream->deallocate(_current_buffer, _next_buffer_size);
                _current_buffer = _initial_buffer;
            }
        }
    }

protected:
    memory_resource * _upstream;
    std::uint8_t * _initial_buffer;
    std::size_t _initial_buffer_size;
    std::uint8_t * _current_buffer;
    std::size_t _next_buffer_size;
}; // class monotonic_buffer_resource


}; // namespace std::pmr

#endif // _STD_MEMORY_RESOURCE_HPP
