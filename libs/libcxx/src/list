/**
 * @file
 * @brief Implementation of the std::list class.
 * 
 * @note Some comments in this file were based off of/taken directly from the
 * descriptions on https://en.cppreference.com/w/cpp/container/list and various
 * subpages. All errors are mine, all credit is theirs.
 */
#ifndef _STD_LIST_HPP
#define _STD_LIST_HPP

#include <cstdint>
#include <memory>
#include <memory_resource>
#include <utility>

namespace std {

template <class T>
struct list_element {
    struct list_element<T> * next;
    struct list_element<T> * prev;
    T value;
}; // list_element

template <class T>
class list_iterator {
private:
    struct list_element<T> * _current;

    template <class U, class Allocator>
    friend class list;

public:
    list_iterator(struct list_element<T> * in_start_element) : _current(in_start_element) {};
    bool operator==(const list_iterator<T>& in_other) const { return (_current == in_other._current); }
    bool operator!=(const list_iterator<T>& in_other) const { return !(*this == in_other); }

    T operator*() { return _current->value; }

    list_iterator<T>& operator++() {
        _current = _current->next;
        return *this;
    }

    list_iterator<T>& operator++(int) {
        auto tmp = *this;
        _current = _current->next;
        return tmp;
    }

    list_iterator<T>& operator--() {
        _current = _current->prev;
        return *this;
    }
}; // list_iterator

template <class T, class Allocator = allocator<T>>
class list {
public:
    using value_type             = T;
    using allocator_type         = Allocator;
    using size_type              = std::size_t;
    using difference_type        = std::ptrdiff_t;
    using reference              = value_type&;
    using const_reference        = const value_type&;
    using pointer                = typename allocator_traits<Allocator>::pointer;
    using const_pointer          = typename allocator_traits<Allocator>::const_pointer;
    using iterator               = typename list_iterator<T>;
    using const_iterator         = const iterator;
    // using reverse_iterator       = std::reverse_iterator<iterator>;
    // using const_reverse_iterator = std::reverse_iterator<const_iterator>;


    using _element_allocator_type = typename allocator_traits<Allocator>::template rebind_alloc<struct list_element<T>>;

    list() {
        _alloc = _element_allocator_type();
        _start = list_element<T> { .next = &_start, .prev = &_start, .value = T() };
    }

    explicit list(const Allocator& in_alloc) {
        _alloc = _element_allocator_type(in_alloc);
        _start = list_element<T> { .next = &_start, .prev = &_start, .value = T() };
    }

    explicit list (size_type in_count, const T& in_value, const Allocator& in_alloc = Allocator()) {
        _alloc = _element_allocator_type(in_alloc);
        _start = list_element<T> { .next = &_start, .prev = &_start, .value = T() };
        insert(cend(), in_count, in_value);
    }

    allocator_type get_allocator() const noexcept { return _alloc; }

    reference front() {
        assert(_length_items > 0);
        return *begin();
    }

    const_reference front() const {
        assert(_length_items > 0);
        return *cbegin();
    }

    reference back() {
        assert(_length_items > 0);
        return *list_iterator<T>(_start->prev);
    }

    const_reference back() const { return back(); }

    iterator begin() noexcept { return list_iterator<T>(_start.next); }
    const_iterator begin() const noexcept { return list_iterator<T>(_start.next); }
    const_iterator cbegin() const noexcept {return list_iterator<T>(_start.next); }
    iterator end() noexcept { return list_iterator<T>(&_start); }
    const_iterator end() const noexcept { return list_iterator<T>(&_start); }
    const_iterator cend() const noexcept { return list_iterator<T>((std::list_element<T> *)&_start); }

    [[nodiscard]] bool empty() const noexcept { return _length_items == 0; }
    size_type size() const noexcept { return _length_items; }
    size_type max_size() const noexcept { return (size_type)UINT32_MAX; }

    void clear() noexcept { erase(cbegin(), cend()); }

    iterator erase(const_iterator in_pos) {
        iterator next = iterator(in_pos._current->next);
        return erase(in_pos, next);
    }

    iterator erase(const_iterator in_first, const_iterator in_last) {
        if(in_first == in_last) { return in_last; }
        assert(in_first != cend());

        iterator cur_iterator = iterator(in_first._current);
        while(cur_iterator != in_last) {
            auto cur_element = cur_iterator._current;
            auto next_element = cur_element->next;
            auto prev_element = cur_element->prev;
            prev_element->next = next_element;
            next_element->prev = prev_element;
            _alloc.deallocate(cur_element, 1);
            ++cur_iterator;
            _length_items--;
        }

        return in_last;
    }

    iterator insert(const_iterator in_pos, const T& in_value) { return insert(in_pos, 1, in_value); }
    iterator insert(const_iterator in_pos, T&& in_value) { return insert(in_pos, 1, std::move(in_value)); }
    iterator insert(const_iterator in_pos, size_type in_count, const T& in_value) {
        if(in_count == 0) { return in_pos; }

        auto first_element = _alloc.allocate(in_count);
        auto new_element = first_element;
        for(auto i = 0; i < in_count; i++) {
            auto cur = in_pos._current;
            assert(cur != nullptr);
            new_element->value = in_value;
            new_element->next = cur;
            new_element->prev = cur->prev;
            cur->prev->next = new_element;
            cur->prev = new_element;

            _length_items++;
            new_element++;
        }
        return list_iterator<T>(first_element);
    }

    template <typename InputIt>
    iterator insert(const_iterator in_pos, InputIt in_first, InputIt in_last) {
        if(in_first == in_last) { return in_pos; }

        auto first_element = nullptr;
        for(; in_first != in_last; in_first++) {
            auto cur_element = insert(in_pos, *in_first);
            if(first_element == nullptr) {
                first_element = cur_element;
            }
        }
        return list_iterator<T>(first_element);
    }

    iterator insert(const_iterator in_pos, std::initializer_list<T> in_ilist) {
        return insert(in_pos, in_ilist.begin(), in_ilist.end());
    }

    void push_back(const T& in_value) { insert(cend(), 1, in_value); }

private:
    _element_allocator_type _alloc;
    struct list_element<T> _start;
    size_type _length_items = 0;
}; // class list

}; // namespace std

namespace std::pmr {

template <class T>
using list = std::list<T, std::pmr::polymorphic_allocator<T>>;

}; // namespace std::pmr

#endif // _STD_LIST_HPP