/**
 * @file
 * @brief Implementations of general-purpose utility functions for working
 * with objects and lvalue/rvalue references to them, as defined by C++20
 * (N4849 draft) sections 20.2, 20.3, and 20.4.
 * 
 * @note Some comments and implementations in this file were based off of or
 * taken directly from the descriptions on
 * https://en.cppreference.com/w/cpp/header/utility and various subpages.
 * All errors are mine, all credit is theirs.
 */
#ifndef _STD_UTILITY_HPP
#define _STD_UTILITY_HPP

#include <__utility/__declval.hpp>
#include <type_traits>

namespace std {

/**
 * @brief Forwards lvalues as either lvalues or rvalues, depending on `T`. Used
 * to implement perfect forwarding.
 * 
 * @tparam T type of object to forward
 * @param in_obj object to be forwarded
 * @return constexpr T&& object cast to the specified type
 */
template <typename T>
constexpr T&& forward(std::remove_reference_t<T>& in_obj) noexcept {
    return static_cast<T&&>(in_obj);
}

/**
 * @brief Forwards rvalues as rvalues, preventing forwarding of lvalues. Used
 * to implement perfect forwarding.
 * 
 * @tparam T type of object to forward
 * @param in_obj object to be forwarded
 * @return constexpr T&& object cast to the specified type
 */
template <typename T>
constexpr T&& forward(std::remove_reference_t<T>&& in_obj) noexcept {
    static_assert(!std::is_lvalue_reference<T>(), "cannot forward lvalue");
    return static_cast<T&&>(in_obj);
}

/**
 * @brief Indicates that the object `in_obj` may be "moved from" instead of
 * requiring a copy, allowing efficient transfer of resources from `in_obj` to
 * another object.
 * 
 * @tparam T type of object to move
 * @param in_obj the object to be moved
 * @return std::remove_reference_t<T>&& an xvalue expression that identifies
 * its argument `in_obj`
 */
template <typename T>
constexpr std::remove_reference_t<T>&& move(T&& in_obj) noexcept {
    return static_cast<typename std::remove_reference<T>::type&&>(in_obj);
}

}; // namespace std

#endif // _STD_UTILITY_HPP
