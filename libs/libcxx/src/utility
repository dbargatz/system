/**
 * @file
 * @brief Implementations of general-purpose utility functions for working
 * with objects and lvalue/rvalue references to them, as defined by C++20
 * (N4849 draft) sections 20.2, 20.3, and 20.4.
 * 
 * @note Some comments and implementations in this file were based off of or
 * taken directly from the descriptions on
 * https://en.cppreference.com/w/cpp/header/utility and various subpages.
 * All errors are mine, all credit is theirs.
 */
#ifndef _STD_UTILITY_HPP
#define _STD_UTILITY_HPP

#include <__utility/__declval.hpp>
#include <initializer_list>
#include <type_traits>

namespace std {

namespace details {

template <typename T>
using __swap_result_t = typename std::enable_if<std::is_move_constructible_v<T> && std::is_move_assignable_v<T>>::type;

}; // namespace details

/**
 * @brief Forwards lvalues as either lvalues or rvalues, depending on `T`. Used
 * to implement perfect forwarding.
 * 
 * @tparam T type of object to forward
 * @param in_obj object to be forwarded
 * @return constexpr T&& object cast to the specified type
 */
template <typename T>
constexpr T&& forward(std::remove_reference_t<T>& in_obj) noexcept {
    return static_cast<T&&>(in_obj);
}

/**
 * @brief Forwards rvalues as rvalues, preventing forwarding of lvalues. Used
 * to implement perfect forwarding.
 * 
 * @tparam T type of object to forward
 * @param in_obj object to be forwarded
 * @return constexpr T&& object cast to the specified type
 */
template <typename T>
constexpr T&& forward(std::remove_reference_t<T>&& in_obj) noexcept {
    static_assert(!std::is_lvalue_reference<T>(), "cannot forward lvalue");
    return static_cast<T&&>(in_obj);
}

/**
 * @brief Indicates that the object `in_obj` may be "moved from" instead of
 * requiring a copy, allowing efficient transfer of resources from `in_obj` to
 * another object.
 * 
 * @tparam T type of object to move
 * @param in_obj the object to be moved
 * @return std::remove_reference_t<T>&& an xvalue expression that identifies
 * its argument `in_obj`
 */
template <typename T>
constexpr std::remove_reference_t<T>&& move(T&& in_obj) noexcept {
    return static_cast<typename std::remove_reference<T>::type&&>(in_obj);
}

/**
 * @brief Swaps the given values `in_lhs` and `in_rhs`. Does not participate
 * in overload resolution unless `T` is both move-assignable and move-
 * constructible.
 * 
 * @tparam T type of the objects to swap
 * @param in_lhs object to swap with `in_rhs`
 * @param in_rhs object to swap with `in_lhs`
 */
template <typename T>
constexpr details::__swap_result_t<T> swap(T& in_lhs, T& in_rhs) noexcept {
    T temp = move(in_lhs);
    in_lhs = move(in_rhs);
    in_rhs = move(temp);
}

}; // namespace std

#endif // _STD_UTILITY_HPP
