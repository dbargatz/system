/**
 * @file
 * @brief Implementations of the std::allocator and std::allocator_traits
 * classes.
 * 
 * @note Some comments in this file were based off of/taken directly from the
 * descriptions on https://en.cppreference.com/w/cpp/memory/allocator and
 * various subpages. All errors are mine, all credit is theirs.
 */
#ifndef _STD_MEMORY_HPP
#define _STD_MEMORY_HPP

#include <cstddef>
#include <new>
#include <type_traits>

namespace std {

/**
 * @brief Obtains the actual address of the object or function `in_arg`, even
 * in the presence of an overloaded `operator&`.
 * 
 * @note The rvalue version of `std::addressof` is deleted to avoid taking the
 * address of `const` rvalues.
 * 
 * @tparam T type of `in_arg`
 * @param in_arg object to get the address of
 * @return `constexpr T*` - pointer to `in_arg`
 */
template <typename T>
inline constexpr T* addressof(T& in_arg) noexcept { return __builtin_addressof(in_arg); }

/**
 * @brief Obtains the actual address of the object or function `in_arg`, even
 * in the presence of an overloaded `operator&`.
 * 
 * @note The rvalue version of `std::addressof` is deleted to avoid taking the
 * address of `const` rvalues.
 * 
 * @tparam T type of `in_arg`
 * @param in_arg object to get the address of
 * @return `constexpr T*` - pointer to `in_arg`
 */
template <typename T>
const T* addressof(const T&& in_arg) noexcept = delete;

template <class Alloc>
struct allocator_traits {
public:
    using allocator_type = Alloc;
    using value_type = typename Alloc::value_type;
    using pointer = value_type*;
    using const_pointer = const value_type*;
    using void_pointer = void*;
    using const_void_pointer = const void*;

    // using difference_type = typename Alloc::difference_type;
    // using size_type = typename Alloc::size_type;

    // using propagate_on_container_copy_assignment = typename Alloc::propagate_on_container_copy_assignment;
    // using propagate_on_container_move_assignment = typename Alloc::propagate_on_container_move_assignment;
    // using propagate_on_container_swap = typename Alloc::propagate_on_container_swap;

    // using is_always_equal = typename Alloc::is_always_equal;

    template <class _Alloc, class U>
    struct __allocator_traits_rebind { };

    template <template <class, class...> class _Alloc, class T, class ..._Args, class U>
    struct __allocator_traits_rebind<_Alloc<T, _Args...>, U> {
        using type = _Alloc<U, _Args...>;
    };

    template <class U>
    using rebind_alloc = typename __allocator_traits_rebind<Alloc, U>::type;

    template <class T>
    using rebind_traits = allocator_traits<rebind_alloc<T>>;
}; // struct allocator_traits

template <class T>
struct allocator {
public:
    using value_type = T;
    using size_type = std::size_t;
    using difference_type = std::ptrdiff_t;
    using propagate_on_container_move_assignment = std::true_type;

    constexpr allocator() noexcept {}
    constexpr allocator(const allocator& in_other) noexcept {}

    template<class U>
    constexpr allocator(const allocator<U>& in_other) noexcept {}

    constexpr ~allocator() {}

    constexpr allocator& operator=(const allocator&) = default;

    [[nodiscard]] constexpr T* allocate(std::size_t in_n) {
        auto size = sizeof(T) * in_n;
        return static_cast<T*>(::operator new(size));
    }

    constexpr void deallocate(T* in_ptr, std::size_t in_n) {
        ::operator delete(in_ptr);
    }
}; // struct allocator

template <class T1, class T2>
constexpr bool operator==(const allocator<T1>& in_lhs, const allocator<T2>& in_rhs) noexcept {
    return true;
}

}; // namespace std

#endif // _STD_MEMORY_HPP