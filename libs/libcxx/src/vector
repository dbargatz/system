/**
 * @file
 * @brief Implementation of the std::vector class.
 * 
 * @note Some comments in this file were based off of/taken directly from the
 * descriptions on https://en.cppreference.com/w/cpp/container/vector and
 * various subpages. All errors are mine, all credit is theirs.
 */
#ifndef _STD_VECTOR_HPP
#define _STD_VECTOR_HPP

#include <cstring>
#include <memory>

namespace std {

// TODO: comments
template<class T, class Allocator = allocator<T>>
class vector {
public:
    // types
    using value_type             = T;
    using allocator_type         = Allocator;
    using pointer                = typename allocator_traits<Allocator>::pointer;
    using const_pointer          = typename allocator_traits<Allocator>::const_pointer;
    using reference              = value_type&;
    using const_reference        = const value_type&;
    using size_type              = std::size_t;
    using difference_type        = std::ptrdiff_t;
    // using iterator               = /* implementation-defined */;
    // using const_iterator         = /* implementation-defined */;
    // using reverse_iterator       = std::reverse_iterator<iterator>;
    // using const_reverse_iterator = std::reverse_iterator<const_iterator>;

    // construct/copy/destroy
    constexpr vector() noexcept(noexcept(Allocator())) : vector(Allocator()) { }
    constexpr explicit vector(const Allocator& in_alloc) noexcept { _alloc = in_alloc; }
    constexpr vector(size_type in_count, const T& in_value, const Allocator& in_alloc = Allocator()) {
        _alloc = in_alloc;
        _buf = _alloc.allocate(in_count);
        _capacity_items = in_count;
        _length_items = in_count;
        for(auto i = 0; i < in_count; i++) { _buf[i] = in_value; }
    }
    constexpr explicit vector(size_type in_count, const Allocator& in_alloc = Allocator()) {
        _alloc = in_alloc;
        _buf = _alloc.allocate(in_count);
        _capacity_items = in_count;
        _length_items = in_count;
        for(auto i = 0; i < in_count; i++) { ::operator new((void *)(_buf + i)) T(); }
    }
    // template<class InputIt>
    // constexpr vector(InputIt first, InputIt last, const Allocator& = Allocator());
    // constexpr vector(const vector& x);
    // constexpr vector(vector&&) noexcept;
    // constexpr vector(const vector&, const Allocator&);
    // constexpr vector(vector&&, const Allocator&);
    // constexpr vector(initializer_list<T>, const Allocator& = Allocator());

    constexpr ~vector() { _reset(); }

    // constexpr vector& operator=(const vector& x);
    // constexpr vector& operator=(vector&& x)
    //   noexcept(allocator_traits<Allocator>::propagate_on_container_move_assignment::value ||
    //            allocator_traits<Allocator>::is_always_equal::value);
    // constexpr vector& operator=(initializer_list<T>);
    // template<class InputIt>
    // constexpr void assign(InputIt first, InputIt last);

    constexpr void assign(size_type in_count, const T& in_value) {
        _reset();
        _buf = alloc.allocate(in_count);
        _capacity_items = in_count;
        _length_items = in_count;
        for(auto i = 0; i < in_count; i++) { _buf[i] = in_value; }
    }

    // constexpr void assign(initializer_list<T>);

    constexpr allocator_type get_allocator() const noexcept { return _alloc; }

private:
    const allocator_type _alloc;
    value_type * _buf = nullptr;
    size_type _capacity_items = 0;
    size_type _length_items = 0;

    constexpr void _reset() {
        if(_buf != nullptr) {
            for(auto i = 0; i < _length_items; i++) { _buf[i].~T(); }
            _alloc.deallocate(_buf, _capacity_items * sizeof(T));
        }
        _buf = nullptr;
        _capacity_items = 0;
        _length_items = 0;
    }
}; // class vector

}; // namespace std

#endif // _STD_VECTOR_HPP