/**
 * @file
 * @brief Implementation of the std::vector class.
 * 
 * @note Some comments in this file were based off of/taken directly from the
 * descriptions on https://en.cppreference.com/w/cpp/container/vector and
 * various subpages. All errors are mine, all credit is theirs.
 */
#ifndef _STD_VECTOR_HPP
#define _STD_VECTOR_HPP

#include <cstring>
#include <memory>
#include <new>

namespace std {

// TODO: comments
template<class T, class Allocator = allocator<T>>
class vector {
public:
    // types
    using value_type             = T;
    using allocator_type         = Allocator;
    using pointer                = typename allocator_traits<Allocator>::pointer;
    using const_pointer          = typename allocator_traits<Allocator>::const_pointer;
    using reference              = value_type&;
    using const_reference        = const value_type&;
    using size_type              = std::size_t;
    using difference_type        = std::ptrdiff_t;
    using iterator               = pointer;
    using const_iterator         = const_pointer;
    // using reverse_iterator       = std::reverse_iterator<iterator>;
    // using const_reverse_iterator = std::reverse_iterator<const_iterator>;

    // construct/copy/destroy
    constexpr vector() noexcept(noexcept(Allocator())) : vector(Allocator()) { }
    constexpr explicit vector(const Allocator& in_alloc) noexcept { _alloc = in_alloc; }
    constexpr vector(size_type in_count, const T& in_value, const Allocator& in_alloc = Allocator()) : vector(in_alloc) {
        resize(in_count, in_value);
    }
    constexpr explicit vector(size_type in_count, const Allocator& in_alloc = Allocator()) : vector(in_alloc) {
        resize(in_count);
    }
    // template<class InputIt>
    // constexpr vector(InputIt first, InputIt last, const Allocator& = Allocator());
    // constexpr vector(const vector& x);
    // constexpr vector(vector&&) noexcept;
    // constexpr vector(const vector&, const Allocator&);
    // constexpr vector(vector&&, const Allocator&);
    // constexpr vector(initializer_list<T>, const Allocator& = Allocator());

    constexpr ~vector() { _reset(); }

    // constexpr vector& operator=(const vector& x);
    // constexpr vector& operator=(vector&& x)
    //   noexcept(allocator_traits<Allocator>::propagate_on_container_move_assignment::value ||
    //            allocator_traits<Allocator>::is_always_equal::value);
    // constexpr vector& operator=(initializer_list<T>);
    // template<class InputIt>
    // constexpr void assign(InputIt first, InputIt last);

    constexpr void assign(size_type in_count, const T& in_value) {
        _reset();
        resize(in_count, in_value);
    }

    // constexpr void assign(initializer_list<T>);

    constexpr allocator_type get_allocator() const noexcept { return _alloc; }


    // iterators
    constexpr iterator begin() noexcept { return _buf; }
    constexpr const_iterator begin() const noexcept { return _buf; }
    constexpr iterator end() noexcept { return (_length_items > 0 ? _buf + _length_items : _buf + 1); }
    constexpr const_iterator end() const noexcept { return (_length_items > 0 ? _buf + _length_items : _buf + 1); }
    // constexpr reverse_iterator       rbegin() noexcept;
    // constexpr const_reverse_iterator rbegin() const noexcept;
    // constexpr reverse_iterator       rend() noexcept;
    // constexpr const_reverse_iterator rend() const noexcept;

    constexpr const_iterator cbegin() const noexcept { return _buf; }
    constexpr const_iterator cend() const noexcept { return (_length_items > 0 ? _buf + _length_items : _buf + 1); }
    // constexpr const_reverse_iterator crbegin() const noexcept;
    // constexpr const_reverse_iterator crend() const noexcept;
 

    // capacity
    [[nodiscard]] constexpr bool empty() const noexcept { return (_length_items == 0); }
    constexpr size_type size() const noexcept { return _length_items; }
    // constexpr size_type max_size() const noexcept;
    constexpr size_type capacity() const noexcept { return _capacity_items; }
    constexpr void resize(size_type in_count) {
        // Increase the vector capacity if necessary.
        reserve(in_count);

        // If the number of items grew, we use the placement new construction
        // so the newly-added items appear default-inserted. This loop will
        // never be executed if the number of items shrunk, because
        // _length_items >= in_count.
        for(auto i = _length_items; i < in_count; i++) {
            ::operator new(_buf + i)();
        }
        _length_items = in_count;
    }

    constexpr void resize(size_type in_count, const T& in_value) {
        // Increase the vector capacity if necessary.
        reserve(in_count);

        // If the number of items grew, we need to copy-construct the additional
        // elements with the provided in_value. This loop will never be executed
        // if the number of items shrunk, because _length_items >= in_count.
        for(auto i = _length_items; i < in_count; i++) { _buf[i] = in_value; }
        _length_items = in_count;
    }

    constexpr void reserve(size_type in_capacity) {
        auto new_cap = _exponential_capacity(in_capacity);
        if(new_cap <= _capacity_items) { return; }

        auto cur_buf = _buf;
        _buf = _alloc.allocate(new_cap);
        for(auto i = 0; i < _length_items; i++) { _buf[i] = cur_buf[i]; }

        if(cur_buf != nullptr) {
            _alloc.deallocate(cur_buf, _capacity_items);
        }

        _capacity_items = new_cap;
    }

    constexpr void shrink_to_fit() {
        auto new_cap = _exponential_capacity(_length_items);
        if(new_cap >= _capacity_items) { return; }
        if(new_cap == 0) { _reset(); return ;}

        auto cur_buf = _buf;
        _buf = _alloc.allocate(new_cap);
        for(auto i = 0; i < _length_items; i++) { _buf[i] = cur_buf[i]; }

        if(cur_buf != nullptr) {
            _alloc.deallocate(cur_buf, _capacity_items);
        }

        _capacity_items = new_cap;
    }

    // element access
    constexpr reference operator[](size_type in_pos) { return _buf[in_pos]; }
    constexpr const_reference operator[](size_type in_pos) const { return _buf[in_pos]; }
    constexpr const_reference at(size_type in_pos) const {
        assert(in_pos < _length_items);
        return _buf[in_pos];
    }

    constexpr reference at(size_type in_pos) {
        assert(in_pos < _length_items);
        return _buf[in_pos];
    }

    // constexpr reference front();
    // constexpr const_reference front() const;
    // constexpr reference back();
    // constexpr const_reference back() const;
 
    // data access
    constexpr T* data() noexcept { return _buf; }
    constexpr const T* data() const noexcept { return _buf; }

    // modifiers
    // template<class... Args>
    // constexpr reference emplace_back(Args&&... in_args);
    constexpr void push_back(const T& in_value) {
        // Make sure there's enough space for the new item.
        reserve(_length_items + 1);
        _buf[_length_items] = in_value;
        _length_items++;
    }

    constexpr void push_back(T&& in_value) {
        // Make sure there's enough space for the new item.
        reserve(_length_items + 1);
        _buf[_length_items] = in_value;
        _length_items++;
    }

    constexpr void pop_back() {
        assert(_length_items > 0);
        _length_items--;
    }
 
    // template<class... Args>
    // constexpr iterator emplace(const_iterator in_position, Args&&... in_args);
    constexpr iterator insert(const_iterator in_position, const T& in_value) {
        assert(in_position >= begin());
        assert(in_position < end());

        // Convert the iterator to an index in the buffer.
        auto idx = (std::size_t)(in_position - _buf);

        // Make sure there's enough space for the new item.
        reserve(_length_items + 1);

        // Shift all the following items to the right by one slot.
        for(auto i = _length_items; i > idx; i--) {
            _buf[i] = _buf[i - 1];
        }

        // Insert the given value and do bookkeeping.
        _buf[idx] = in_value;
        _length_items++;
        return (iterator)&_buf[idx];
    }
    // constexpr iterator insert(const_iterator in_position, T&& in_value);
    // constexpr iterator insert(const_iterator in_position, size_type in_count, const T& in_value);
    // template<class InputIt>
    // constexpr iterator insert(const_iterator in_position, InputIt in_first, InputIt in_last);
    // constexpr iterator insert(const_iterator in_position, initializer_list<T> il);
    constexpr iterator erase(const_iterator in_position) {
        assert(in_position >= begin());
        assert(in_position < end());

        // Convert the iterator to an index in the buffer.
        auto idx = (std::size_t)(in_position - _buf);

        // Shift all the following items to the left by one slot.
        for(auto i = idx; i < _length_items; i++) {
            _buf[i] = _buf[i + 1];
        }

        // Bookkeeping.
        _length_items--;
        return (iterator)&_buf[idx];
    }
    // constexpr iterator erase(const_iterator in_first, const_iterator in_last);
    // constexpr void swap(vector&) noexcept(allocator_traits<Allocator>::propagate_on_container_swap::value || allocator_traits<Allocator>::is_always_equal::value);
    constexpr void clear() noexcept {
        if(_buf != nullptr) {
            for(auto i = 0; i < _length_items; i++) { _buf[i].~T(); }
        }
        _length_items = 0;
    }

private:
    allocator_type _alloc;
    value_type * _buf = nullptr;
    size_type _capacity_items = 0;
    size_type _length_items = 0;

    constexpr size_type _exponential_capacity(size_type in_capacity) {
        in_capacity = in_capacity - 1;
        in_capacity |= in_capacity >> 1;
        in_capacity |= in_capacity >> 2;
        in_capacity |= in_capacity >> 4;
        in_capacity |= in_capacity >> 8;
        in_capacity |= in_capacity >> 16;
        in_capacity |= in_capacity >> 32;
        in_capacity = in_capacity + 1;
        return in_capacity;
    }

    constexpr void _reset() {
        if(_buf != nullptr) {
            for(auto i = 0; i < _length_items; i++) { _buf[i].~T(); }
            _alloc.deallocate(_buf, _capacity_items * sizeof(T));
        }
        _buf = nullptr;
        _capacity_items = 0;
        _length_items = 0;
    }
}; // class vector

}; // namespace std

#endif // _STD_VECTOR_HPP