/**
 * @file
 * @brief Contains a simple recursive implementation of std::tuple<>.
 */
#ifndef _STD_TUPLE
#define _STD_TUPLE

#include <cstddef>
#include <type_traits>

namespace std {

////////////////////////////////////////////////////////////////////////////////
template <size_t i, typename T>
struct _tuple_leaf {
    T value;

    constexpr _tuple_leaf(const T& in_arg) {
        value = in_arg;
    }
};


////////////////////////////////////////////////////////////////////////////////
template <size_t i, typename... Ts>
struct _tuple;

template <size_t i>
struct _tuple<i> {};

template <size_t i, typename T, typename... Ts>
struct _tuple<i, T, Ts...> : public _tuple_leaf<i, T>,
                             public _tuple<i+1, Ts...> {

constexpr _tuple(const T& in_arg, const Ts&... in_rest) : _tuple_leaf<i, T>(in_arg), _tuple<i+1, Ts...>(in_rest...) { }
};

////////////////////////////////////////////////////////////////////////////////
template <typename... Ts>
using tuple = _tuple<0, Ts...>;


// ////////////////////////////////////////////////////////////////////////////////
template <size_t i, typename T>
struct tuple_element;

template <typename T, typename... Ts>
struct tuple_element<0, tuple<T, Ts...>> {
    using type = T;
};

template <size_t i, typename T, typename... Ts>
struct tuple_element<i, tuple<T, Ts...>> : public tuple_element<i-1, tuple<Ts...>> {};

////////////////////////////////////////////////////////////////////////////////
template <typename T> struct tuple_size;

template <typename... Ts>
struct tuple_size<tuple<Ts...>> : public integral_constant<size_t, sizeof...(Ts)> {};


////////////////////////////////////////////////////////////////////////////////
template<size_t i, typename T, typename... Ts>
const T get(const _tuple<i, T, Ts...>& in_t) {
    return static_cast<_tuple_leaf<i, T>>(in_t).value;
}

}; // namespace std

#endif // _STD_TUPLE