/**
 * @file
 * @brief Contains a simple recursive implementation of std::tuple<>.
 */
#ifndef _STD_TUPLE
#define _STD_TUPLE

#include <cstddef>
#include <type_traits>

namespace std {

////////////////////////////////////////////////////////////////////////////////
template <size_t i, typename T>
struct _tuple_leaf {
    T value;
};


////////////////////////////////////////////////////////////////////////////////
template <size_t i, typename... Ts>
struct _tuple;

template <size_t i>
struct _tuple<i> {};

template <size_t i, typename T, typename... Ts>
struct _tuple<i, T, Ts...> : public _tuple_leaf<i, T>,
                             public _tuple<i+1, Ts...> {};

////////////////////////////////////////////////////////////////////////////////
template <typename... Ts>
using tuple = _tuple<0, Ts...>;


// ////////////////////////////////////////////////////////////////////////////////
// template <size_t i, typename T>
// struct tuple_element {
//     using type = T;
// };

// template <size_t i, typename T, typename... Ts>
// struct tuple_element<i, tuple<Ts...>> : public tuple_element<i, T>,
//                                         public tuple_element<i+1, tuple<Ts...>> {};

////////////////////////////////////////////////////////////////////////////////
// template <typename T> struct tuple_size;

// template <typename... Ts>
// struct tuple_size<tuple<Ts...>> : public integral_constant<size_t, sizeof...(Ts)> {};


////////////////////////////////////////////////////////////////////////////////
template<size_t i, typename T, typename... Ts>
const T& get(_tuple<i, T, Ts...>& in_t) {
    return static_cast<_tuple_leaf<i, T>>(in_t).value;
}

}; // namespace std

#endif // _STD_TUPLE